/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     | Website:  https://openfoam.org
    \\  /    A nd           | Version:  10
     \\/     M anipulation  | Written by Flavio Martins, 2023 (f.m.martins@tudelft.nl)
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     9.0;
    format      ascii;
    class       dictionary;
    location    "constant";
    object      fvOptions;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //


tensorCodedSource
{
    type            coded;
    selectionMode   all;
    field           U;
    name            sourceForce;

    codeAddSup
    #{  
    	#include "./../../../ActuatorsSetup"

        /* ===== Determine the magnitude of the thrust force ===== */

        const scalarField& cellsV = mesh().V();      // get all cell volumes > Pout << cellsV.size() << endl;
        const fvMesh & myMesh = mesh();


        const cellSet BladeCellSet(myMesh, "Blade"); // get the cell set defined by the "actuationDiskCellSet"
        labelList BladeCells = BladeCellSet.toc();  //returnReduce(BladeCells, sumOp<List>());
          
        const cellSet RotorCellSet(myMesh, "Rotor"); // get the cell set defined by the "actuationDiskCellSet"
        labelList RotorCells = RotorCellSet.toc();  //returnReduce(RotorCells, sumOp<List>());
    

        scalar BladeVolume = 0.0;
        for(int i=0; i<BladeCells.size(); i++)
        { 
           BladeVolume += cellsV[BladeCells[i]];
        }
        scalar BladeVolume_ProcVolFrac = BladeVolume/returnReduce(BladeVolume, sumOp<scalar>());


        scalar RotorVolume = 0.0;
        for(int i=0; i<RotorCells.size(); i++)
        { 
            RotorVolume += cellsV[RotorCells[i]];
        }
        scalar RotorVolume_ProcVolFrac = RotorVolume/returnReduce(RotorVolume, sumOp<scalar>());


        /* ===== Apply thrust force to momentum equation ========= */ 
        // Force in each cell = (cell volume)/(Disk volume) * Thurst * Thrust-direction
            
        vectorField& Usource = eqn.source();

        for(int i=0; i<BladeCells.size(); i++)
        {
            Usource[BladeCells[i]] -= (cellsV[BladeCells[i]]/BladeVolume) * BladeForce * BladeVolume_ProcVolFrac;
        }

        for(int i=0; i<RotorCells.size(); i++)                                    
        {
            Usource[RotorCells[i]] -= (cellsV[RotorCells[i]]/RotorVolume) * RotorForce * RotorVolume_ProcVolFrac ;
        }

        /* ===== Keep the user informed ========================== */

	// Sum-up the forces added to all cells. Returns a vector.
        vector localSum = sum(Usource);                 
        
        // reduce to vector. This value should match T*ForceDir                    
        vector totalUSource = returnReduce(localSum, sumOp<vector>() );     
        
        
        Info << "========== Flavio's Actuator Surface Model (2023) ==============" << endl;
        Info << "Disk actuator force: "    << RotorForce << " N" << endl;
        // Info << "Disk actuator: "          << RotorCells.size() << " cells" << endl;
        // Info << "Disk actuator volume: "   << RotorVolume << endl;
        Info << "Blade actuator force: "   << BladeForce << " N" << endl;
        // Info << "Blade actuator: "         << BladeCells.size() << " cells" << endl;
        // Info << "Blade actuator volume: "  << BladeVolume << endl;
        Info << "Momentum Source (Thrust, Vertical Force, Crosswind Force): " << totalUSource  << " N" << endl;
        Info << "================================================================" << endl;
    #};
}

